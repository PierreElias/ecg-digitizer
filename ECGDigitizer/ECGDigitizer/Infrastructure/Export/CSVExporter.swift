import Foundation

/// Exports ECG recordings to CSV format
final class CSVExporter {

    // MARK: - Export Methods

    /// Exports an ECG recording to CSV format
    /// - Parameter recording: The ECG recording to export
    /// - Returns: CSV formatted string
    func export(_ recording: ECGRecording) -> String {
        var csv = ""

        // Add metadata header
        csv += generateMetadataSection(recording)
        csv += "\n"

        // Add lead data
        csv += generateLeadDataSection(recording)

        return csv
    }

    /// Exports an ECG recording to a temporary file
    /// - Parameter recording: The ECG recording to export
    /// - Returns: URL of the temporary CSV file
    func exportToFile(_ recording: ECGRecording) throws -> URL {
        let csv = export(recording)

        let fileName = "\(recording.reportName.replacingOccurrences(of: " ", with: "_")).csv"
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(fileName)

        try csv.write(to: tempURL, atomically: true, encoding: .utf8)

        return tempURL
    }

    // MARK: - Private Methods

    private func generateMetadataSection(_ recording: ECGRecording) -> String {
        var section = "# ECG Recording Metadata\n"
        section += "# Generated by ECG Digitizer\n"
        section += "#\n"
        section += "recording_id,\(recording.id.uuidString)\n"
        section += "timestamp,\(ISO8601DateFormatter().string(from: recording.timestamp))\n"
        section += "layout,\(recording.layout.rawValue)\n"
        section += "paper_speed_mm_s,\(recording.parameters.paperSpeed.mmPerSecond)\n"
        section += "voltage_gain_mm_mv,\(recording.parameters.voltageGain.mmPerMillivolt)\n"
        section += "sampling_rate_hz,\(recording.leads.first?.samplingRate ?? 500)\n"
        section += "lead_count,\(recording.leads.count)\n"
        section += "validation_status,\(recording.validationStatus.rawValue)\n"

        if let calibration = recording.gridCalibration {
            section += "grid_mm_per_pixel_h,\(calibration.mmPerPixelHorizontal)\n"
            section += "grid_mm_per_pixel_v,\(calibration.mmPerPixelVertical)\n"
        }

        return section
    }

    private func generateLeadDataSection(_ recording: ECGRecording) -> String {
        var section = "\n# Lead Data\n"
        section += "# timestamp_ms: Time from start of recording\n"
        section += "# lead: Lead identifier (I, II, III, aVR, aVL, aVF, V1-V6)\n"
        section += "# voltage_mv: Voltage in millivolts\n"
        section += "#\n"
        section += "timestamp_ms,lead,voltage_mv\n"

        for lead in recording.leads {
            let samplingRate = lead.samplingRate
            let sampleIntervalMs = 1000.0 / samplingRate

            for (index, voltage) in lead.samples.enumerated() {
                let timestampMs = Double(index) * sampleIntervalMs
                section += String(format: "%.1f,%@,%.4f\n", timestampMs, lead.type.rawValue, voltage)
            }
        }

        return section
    }

    // MARK: - Wide Format Export

    /// Exports all leads in wide format (one column per lead)
    /// - Parameter recording: The ECG recording to export
    /// - Returns: CSV formatted string with wide format
    func exportWideFormat(_ recording: ECGRecording) -> String {
        var csv = ""

        // Add metadata
        csv += generateMetadataSection(recording)
        csv += "\n"

        // Header row with all lead names
        var header = "timestamp_ms"
        for lead in recording.leads {
            header += ",\(lead.type.rawValue)"
        }
        csv += header + "\n"

        // Find the maximum number of samples across all leads
        let maxSamples = recording.leads.map { $0.samples.count }.max() ?? 0
        let samplingRate = recording.leads.first?.samplingRate ?? 500
        let sampleIntervalMs = 1000.0 / samplingRate

        // Data rows
        for i in 0..<maxSamples {
            let timestampMs = Double(i) * sampleIntervalMs
            var row = String(format: "%.1f", timestampMs)

            for lead in recording.leads {
                if i < lead.samples.count {
                    row += String(format: ",%.4f", lead.samples[i])
                } else {
                    row += ","  // Empty value for shorter leads
                }
            }

            csv += row + "\n"
        }

        return csv
    }

    /// Exports in wide format to a temporary file
    func exportWideFormatToFile(_ recording: ECGRecording) throws -> URL {
        let csv = exportWideFormat(recording)

        let fileName = "\(recording.reportName.replacingOccurrences(of: " ", with: "_"))_wide.csv"
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(fileName)

        try csv.write(to: tempURL, atomically: true, encoding: .utf8)

        return tempURL
    }
}
